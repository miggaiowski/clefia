
* Introdução

  CLEFIA é um algoritmo de cifragem de blocos, desenvolvido pela SONY,
  apresentado em 2007. O tamanho do  bloco é de 128 bits, enquanto que
  o tamanho da chave pode ser de 128, 192 ou 256 bits, fazendo com que
  ele seja compatível com a interface do cifrador AES.

  CLEFIA  foi criado  devido ao  aumento da  demanda  por /lightweight
  cryptography/.  /Lightweight  cryptography/  consiste de  mecanismos
  criptográficos   que  fornecem   segurança  para   dispositivos  com
  capacidades     limitadas,     como     por    exemplo,     sensores
  wireless.  Portanto, CLEFIA  fornece um  alto level  de  segurança e
  ainda  tem  uma elevada  perfomance  tanto  em  software, quanto  em
  hardware.

  Nosso  trabalho consiste  de implementar  o CLEFIA  em  software, na
  linguagem C. Foi  implementado todas as versões de  tamanho de chave
  (128, 192 e  256 bits) e ainda o modo  de operação CBC (Cipher-block
  chaining). Também foram realizados testes de cifragens e decifragens
  de arquivos grandes,  utilizando o modo CBC. Os  mesmos testes foram
  realizados  com o  cifrador AES  também no  modo CBC,  disponível na
  biblioteca   OpenSSL.  Dessa   forma,  foi   possível   comparar  os
  resultados.

* Algoritmo CLEFIA

  O algoritmo CLEFIA consiste em  duas partes, a de geração de chaves,
  e a  do processamento dos dados,  que são as funções  de encriptar e
  decriptar.

  Essa seção irá  descrever com detalhes todas as  funções usadas pelo
  CLEFIA, tanto para a parte de geração de chaves, quanto para a parte
  de encriptar e desencriptar.

** Generalized Feistel Network
    
    CLEFIA utiliza  um 4-branch e  um 8-branch do  Generalized Feistel
    Network(GFN). O  4-branch é utilizado  nas funções de  encriptar e
    decriptar e  também na geração  de chaves no  modo 128 bits.  Já o
    8-branch é aplicado apenas na geração  de chaves do modo 192 e 256
    bits.

   Chamaremos de $GFN_{d, r}$ um GFN onde $d$ é o tamanho do branch, e
   $r$ é o número de rounds.  Abaixo iremos definir o $GFN_{4, r}$ e o
   $GFN_{8,  r}$. Note  que ambos  utilizam as  funções $F$  que serão
   mostradas na próxima subseção. \\

   *GFN_{4,r}(RK_{0}, ..., RK_{2r-1}, X_0, X_1, X_2, X_3)*

   *Entrada* : 32-bit round keys RK_{0}, ..., RK_{2r-1},
               32-bit data X_0, X_1, X_2, X_3,


   *Saída*: 32-bit data Y_0, Y_1, Y_2, Y_3

   *Passo 1.* T_0 | T_1 | T_2 | T_3 \leftarrow X_0 | X_1 | X_2 | X_3

   *Passo 2.* For i = 0 to r - 1 do the following:

   *Passo 2.1.* T_1 \leftarrow T_1 \oplus F0(RK_{2i},T_0),
                T_3 \leftarrow T_3 \oplus F1(RK_{2i + 1}, T_2)

   *Passo 2.2.* T_0 | T_1 | T_2 | T_3 \leftarrow T_1 | T_2 | T_3 | T_0

   *Passo 3.* Y_0 | Y_1 | Y_2 | Y_3 \leftarrow T_3 | T_0 | T_1 | T_2 \\

   *GFN_{8,r}(RK_{0}, ..., RK_{4r-1}, X_0, X_1, ..., X_7)*

   *Entrada* : 32-bit round keys RK_{0}, ..., RK_{4r-1},
                 32-bit data X_0, X_1, X_2, X_3, X_4, X_5, X_6, X_7,

   *Saída*: 32-bit data Y_0, Y_1, Y_2, Y_3, Y_4, Y_5, Y_6, Y_7

   *Passo 1.* T_0 | T_1 | ... | T_7 \leftarrow X_0 | X_1 | ... | X_7

   *Passo 2.* For i = 0 to r - 1 do the following:

   *Passo 2.1.* T_1 \leftarrow T_1 \oplus F0(RK_{4i}, T_0),
                   T_3 \leftarrow T_3 \oplus F1(RK_{4i + 1}, T_2),
                   T_5 \leftarrow T_5 \oplus F0(RK_{4i + 2}, T_4),
                   T_7 \leftarrow T_7 \oplus F1(RK_{4i + 3}, T_6)

   *Passo 2.2.* T_0 | T_1 | ... | T_6 | T_7 \leftarrow T_1 | T_2 | ... | T_7 | T_0

   *Passo 3.* Y_0 | Y_1 | ... | Y_6 | Y_7 \leftarrow T_7 | T_0 | ... |
   T_5 | T_6
   
   Temos também a necessidade de gerar a inversa da GFN_{4, r} para
   que seja usada na função de decriptar. Abaixo, ela é apresentada

     GFNINV_{4,r}(RK_{0}, ..., RK_{2r-1}, X0, X1, X2, X3)

         input : 32-bit round keys RK_{0}, ..., RK_{2r-1},
                 32-bit data X0, X1, X2, X3,

         output: 32-bit data Y0, Y1, Y2, Y3

      Step 1. T0 | T1 | T2 | T3 <- X0 | X1 | X2 | X3

      Step 2. For i = 0 to r - 1 do the following:

         Step 2.1. T1 <- T1 XOR F0(RK_{2(r - i) - 2}, T0),
                   T3 <- T3 XOR F1(RK_{2(r - i) - 1}, T2)

         Step 2.2. T0 | T1 | T2 | T3 <- T3 | T0 | T1 | T2

      Step 3. Y0 | Y1 | Y2 | Y3 <- T1 | T2 | T3 | T0


   
** Funções F

    Já vimos que tanto o 4-branch GFN quanto o 8-branch GNF, utiliza
    duas funções F, denominadas F0 e F1. Abaixo, iremos descrevê-las.

    F0(RK, x)

         input : 32-bit round key RK, 32-bit data x,

         output: 32-bit data y

      Step 1. T <- RK XOR x

      Step 2. Let T = T0 | T1 | T2 | T3, where Ti is 8-bit data,
              T0 <- S0(T0),
              T1 <- S1(T1),
              T2 <- S0(T2),
              T3 <- S1(T3)

      Step 3. Let y = y0 | y1 | y2 | y3, where yi is 8-bit data,
              y <- M0 trans((T0, T1, T2, T3))

   F1(RK, x)

         input : 32-bit round key RK, 32-bit data x,

         output: 32-bit data y

      Step 1. T <- RK XOR x

      Step 2. Let T = T0 | T1 | T2 | T3, where Ti is 8-bit data,
              T0 <- S1(T0),
              T1 <- S0(T1),
              T2 <- S1(T2),
              T3 <- S0(T3)

      Step 3. Let y = y0 | y1 | y2 | y3, where yi is 8-bit data,
              y <- M1 trans((T0, T1, T2, T3))

  Ambas as funções utilizam as S-boxes que serão mostradas abaixo.

** S-boxes

   CLEFIA utiliza dois tipos diferentes de S-box, S0 e S1. As tabelas
   abaixo mostram-nas. Temos que todos os valores estão em
   hexadecimais, e para uma entrada de 8-bit temos que a saída é
   gerada a partir da posição (i, j), onde i é formada pelos 4
   primeiros bits e j pelos 4 últimos.

       Table 1: S-Box S0

      .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .a .b .c .d .e .f
   0. 57 49 d1 c6 2f 33 74 fb 95 6d 82 ea 0e b0 a8 1c
   1. 28 d0 4b 92 5c ee 85 b1 c4 0a 76 3d 63 f9 17 af
   2. bf a1 19 65 f7 7a 32 20 06 ce e4 83 9d 5b 4c d8
   3. 42 5d 2e e8 d4 9b 0f 13 3c 89 67 c0 71 aa b6 f5
   4. a4 be fd 8c 12 00 97 da 78 e1 cf 6b 39 43 55 26
   5. 30 98 cc dd eb 54 b3 8f 4e 16 fa 22 a5 77 09 61
   6. d6 2a 53 37 45 c1 6c ae ef 70 08 99 8b 1d f2 b4
   7. e9 c7 9f 4a 31 25 fe 7c d3 a2 bd 56 14 88 60 0b
   8. cd e2 34 50 9e dc 11 05 2b b7 a9 48 ff 66 8a 73
   9. 03 75 86 f1 6a a7 40 c2 b9 2c db 1f 58 94 3e ed
   a. fc 1b a0 04 b8 8d e6 59 62 93 35 7e ca 21 df 47
   b. 15 f3 ba 7f a6 69 c8 4d 87 3b 9c 01 e0 de 24 52
   c. 7b 0c 68 1e 80 b2 5a e7 ad d5 23 f4 46 3f 91 c9
   d. 6e 84 72 bb 0d 18 d9 96 f0 5f 41 ac 27 c5 e3 3a
   e. 81 6f 07 a3 79 f6 2d 38 1a 44 5e b5 d2 ec cb 90
   f. 9a 36 e5 29 c3 4f ab 64 51 f8 10 d7 bc 02 7d 8e

   Table 2: S-Box S1

      .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .a .b .c .d .e .f
   0. 6c da c3 e9 4e 9d 0a 3d b8 36 b4 38 13 34 0c d9
   1. bf 74 94 8f b7 9c e5 dc 9e 07 49 4f 98 2c b0 93
   2. 12 eb cd b3 92 e7 41 60 e3 21 27 3b e6 19 d2 0e
   3. 91 11 c7 3f 2a 8e a1 bc 2b c8 c5 0f 5b f3 87 8b
   4. fb f5 de 20 c6 a7 84 ce d8 65 51 c9 a4 ef 43 53
   5. 25 5d 9b 31 e8 3e 0d d7 80 ff 69 8a ba 0b 73 5c
   6. 6e 54 15 62 f6 35 30 52 a3 16 d3 28 32 fa aa 5e
   7. cf ea ed 78 33 58 09 7b 63 c0 c1 46 1e df a9 99
   8. 55 04 c4 86 39 77 82 ec 40 18 90 97 59 dd 83 1f
   9. 9a 37 06 24 64 7c a5 56 48 08 85 d0 61 26 ca 6f
   a. 7e 6a b6 71 a0 70 05 d1 45 8c 23 1c f0 ee 89 ad
   b. 7a 4b c2 2f db 5a 4d 76 67 17 2d f4 cb b1 4a a8
   c. b5 22 47 3a d5 10 4c 72 cc 00 f9 e0 fd e2 fe ae
   d. f8 5f ab f1 1b 42 81 d6 be 44 29 a6 57 b9 af f2
   e. d4 75 66 bb 68 9f 50 02 01 3c 7f 8d 1a 88 bd ac
   f. f7 e4 79 96 a2 fc 6d b2 6b 03 e1 2e 7d 14 95 1d


** Matrizes de Difusão

    Vimos que é necessário a multiplicação de um vetor T pelas
    matrizes M0 e M1 na função F0 e F1 respectivamente.

    Abaixo é mostrado como é feito essa multiplicação.

   y = M0 trans((T0, T1, T2, T3)):

     y0 =         T0  XOR (0x02 * T1) XOR (0x04 * T2) XOR (0x06 * T3),
     y1 = (0x02 * T0) XOR         T1  XOR (0x06 * T2) XOR (0x04 * T3),
     y2 = (0x04 * T0) XOR (0x06 * T1) XOR         T2  XOR (0x02 * T3),
     y3 = (0x06 * T0) XOR (0x04 * T1) XOR (0x02 * T2) XOR         T3

   y = M1 trans((T0, T1, T2, T3)):

     y0 =         T0  XOR (0x08 * T1) XOR (0x02 * T2) XOR (0x0a * T3),
     y1 = (0x08 * T0) XOR         T1  XOR (0x0a * T2) XOR (0x02 * T3),
     y2 = (0x02 * T0) XOR (0x0a * T1) XOR         T2  XOR (0x08 * T3),
     y3 = (0x0a * T0) XOR (0x02 * T1) XOR (0x08 * T2) XOR         T3

     Temos que o sinal * indica multiplicação em GF(2^8) onde o
     polinômio primitivo é z^8 + z^4 + z^3 + z^2 + 1. Teremos uma
     seção abaixo explicando como é feito as operações em GF(2^8).

** Algoritmo de encriptação


** Algoritmo de desencriptação
