
* Introdução

  CLEFIA é um algoritmo de cifragem de blocos, desenvolvido pela SONY,
  apresentado em 2007. O tamanho do  bloco é de 128 bits, enquanto que
  o tamanho da chave pode ser de 128, 192 ou 256 bits, fazendo com que
  ele seja compatível com a interface do cifrador AES.

  CLEFIA  foi criado  devido ao  aumento da  demanda  por /lightweight
  cryptography/.  /Lightweight  cryptography/  consiste de  mecanismos
  criptográficos   que  fornecem   segurança  para   dispositivos  com
  capacidades     limitadas,     como     por    exemplo,     sensores
  wireless.  Portanto, CLEFIA  fornece um  alto level  de  segurança e
  ainda  tem  uma elevada  perfomance  tanto  em  software, quanto  em
  hardware.

  Nosso  trabalho consiste  de implementar  o CLEFIA  em  software, na
  linguagem C. Foi  implementado todas as versões de  tamanho de chave
  (128, 192 e  256 bits) e ainda o modo  de operação CBC (Cipher-block
  chaining). Também foram realizados testes de cifragens e decifragens
  de arquivos grandes,  utilizando o modo CBC. Os  mesmos testes foram
  realizados  com o  cifrador AES  também no  modo CBC,  disponível na
  biblioteca   OpenSSL.  Dessa   forma,  foi   possível   comparar  os
  resultados.

* Algoritmo CLEFIA

  O algoritmo CLEFIA consiste em  duas partes, a de geração de chaves,
  e a  do processamento dos dados,  que são as funções  de encriptar e
  decriptar.

  Essa seção irá  descrever com detalhes todas as  funções usadas pelo
  CLEFIA, tanto para a parte de geração de chaves, quanto para a parte
  de encriptar e desencriptar.

** Blocos do Clefia

*** Generalized Feistel Network
    
    CLEFIA utiliza  um 4-branch e  um 8-branch do  Generalized Feistel
    Network(GFN). O  4-branch é utilizado  nas funções de  encriptar e
    decriptar e  também na geração  de chaves no  modo 128 bits.  Já o
    8-branch é aplicado apenas na geração  de chaves do modo 192 e 256
    bits.

   Chamaremos de $GFN_{d, r}$ um GFN onde $d$ é o tamanho do branch, e
   $r$ é o número de rounds.  Abaixo iremos definir o $GFN_{4, r}$ e o
   $GFN_{8,  r}$. Note  que ambos  utilizam as  funções $F$  que serão
   mostradas na próxima subseção. \\

   *GFN_{4,r}(RK_{0}, ..., RK_{2r-1}, X_0, X_1, X_2, X_3)*

   *Entrada* : 32-bit round keys RK_{0}, ..., RK_{2r-1},
               32-bit data X_0, X_1, X_2, X_3,


   *Saída*: 32-bit data Y_0, Y_1, Y_2, Y_3

   *Passo 1.* T_0 | T_1 | T_2 | T_3 \leftarrow X_0 | X_1 | X_2 | X_3

   *Passo 2.* Para i = 0 até $r-1$ faça:

   *Passo 2.1.* T_1 \leftarrow T_1 \oplus F0(RK_{2i},T_0),
                T_3 \leftarrow T_3 \oplus F1(RK_{2i + 1}, T_2)

   *Passo 2.2.* T_0 | T_1 | T_2 | T_3 \leftarrow T_1 | T_2 | T_3 | T_0

   *Passo 3.* Y_0 | Y_1 | Y_2 | Y_3 \leftarrow T_3 | T_0 | T_1 | T_2 \\

   *GFN_{8,r}(RK_{0}, ..., RK_{4r-1}, X_0, X_1, ..., X_7)*

   *Entrada* : 32-bit round keys RK_{0}, ..., RK_{4r-1},
               32-bit data X_0, X_1, X_2, X_3, X_4, X_5, X_6, X_7,

   *Saída*: 32-bit data Y_0, Y_1, Y_2, Y_3, Y_4, Y_5, Y_6, Y_7

   *Passo 1.* T_0 | T_1 | ... | T_7 \leftarrow X_0 | X_1 | ... | X_7

   *Passo 2.* Para i = 0 até $r-1$ faça:

   *Passo 2.1.* T_1 \leftarrow T_1 \oplus F0(RK_{4i}, T_0),
                T_3 \leftarrow T_3 \oplus F1(RK_{4i + 1}, T_2),
                T_5 \leftarrow T_5 \oplus F0(RK_{4i + 2}, T_4),
                T_7 \leftarrow T_7 \oplus F1(RK_{4i + 3}, T_6)

   *Passo 2.2.* T_0 | T_1 | ... | T_6 | T_7 \leftarrow T_1 | T_2 | ... | T_7 | T_0

   *Passo 3.* Y_0 | Y_1 | ... | Y_6 | Y_7 \leftarrow T_7 | T_0 | ... |
   T_5 | T_6
   
   Temos também a necessidade de gerar a inversa da GFN_{4, r} para
   que seja usada na função de decriptar. Abaixo, ela é apresentada

     GFNINV_{4,r}(RK_{0}, ..., RK_{2r-1}, X0, X1, X2, X3)

         input : 32-bit round keys RK_{0}, ..., RK_{2r-1},
                 32-bit data X0, X1, X2, X3,

         output: 32-bit data Y0, Y1, Y2, Y3

      Step 1. T0 | T1 | T2 | T3 <- X0 | X1 | X2 | X3

      Step 2. For i = 0 to r - 1 do the following:

         Step 2.1. T1 <- T1 XOR F0(RK_{2(r - i) - 2}, T0),
                   T3 <- T3 XOR F1(RK_{2(r - i) - 1}, T2)

         Step 2.2. T0 | T1 | T2 | T3 <- T3 | T0 | T1 | T2

      Step 3. Y0 | Y1 | Y2 | Y3 <- T1 | T2 | T3 | T0


   
*** Funções F

    Já vimos que tanto o 4-branch GFN quanto o 8-branch GNF, utiliza
    duas funções F, denominadas F0 e F1. Abaixo, iremos descrevê-las.

      
* Resultados experimentais
  Com o  intuito de compararar o  algoritmo Clefia com  o AES, fizemos
  vários testes  de cifragem e decifragem. Os  tempos obtidos aparecem
  nas tabelas abaixo. 
  
  É óbvio  que a  implementação do AES  da biblioteca OpenSSL  é muito
  rápida,  já que o  código aberto  vem sendo  testado e  otimizado há
  bastante tempo. 
  
  Nosso código, por outro lado,  foi escrito por duas pessoas apenas e
  sem  o tempo  necessário para  fazer otimizações  mais  profundas no
  código.  
  
  Apesar disso, a primeira implementação  era $10\%$ mais lenta. O que
  fizemos para acelerar um pouco a execução foram
  pequenas otimizações de código, como /loop unrolling/ de alguns
  laços e trocar funções por  macros, que são substituídas em tempo de
  compilação.  Acreditamos que com mais tempo e mais otimizações
  poderíamos deminuir drasticamente os tempos apresentados.
  
  Nas tabelas a seguir, temos os tempos de execução de cada um dos dez
  testes feitos.  O arquivo cifrado  é uma imagem de  uma distribuição
  Linux, de 200278016 bytes.

|---------------+-------------+----------------|
| Cifrar        | AES-128 (s) | Clefia-128 (s) |
|---------------+-------------+----------------|
| Teste 1       |       1.996 |         31.778 |
| Teste 2       |       1.933 |         31.783 |
| Teste 3       |       2.030 |         31.773 |
| Teste 4       |       1.933 |         31.782 |
| Teste 5       |       2.026 |         31.782 |
| Teste 6       |       2.059 |         31.786 |
| Teste 7       |       2.078 |         31.791 |
| Teste 8       |       2.124 |         31.785 |
| Teste 9       |       1.948 |         31.904 |
| Teste 10      |       1.981 |         31.775 |
|---------------+-------------+----------------|
| Média         |      2.0108 |        31.7939 |
| Desvio Padrão |      0.0644 |         0.0390 |
|---------------+-------------+----------------|

|---------------+-------------+----------------|
| Decifrar      | AES-128 (s) | Clefia-128 (s) |
|---------------+-------------+----------------|
| Teste 1       |       2.081 |         33.233 |
| Teste 2       |       2.025 |         33.256 |
| Teste 3       |       2.059 |         33.261 |
| Teste 4       |       2.065 |         33.236 |
| Teste 5       |       2.051 |         33.268 |
| Teste 6       |       2.021 |         33.499 |
| Teste 7       |       2.044 |          33.13 |
| Teste 8       |       2.029 |         33.034 |
| Teste 9       |       2.034 |         33.335 |
| Teste 10      |       2.049 |         33.243 |
|---------------+-------------+----------------|
| Média         |      2.0458 |        33.2495 |
| Desvio Padrão |      0.0191 |         0.1207 |
|---------------+-------------+----------------|

  
