#+TITLE:     Relatório Trabalho de Introdução a Criptografia
#+AUTHOR:    Miguel Gaiowski e Douglas Santos
#+EMAIL:     bla
#+DATE:      2012-06-27 Wed
#+DESCRIPTION: 
#+KEYWORDS: 
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+LATEX_HEADER: \usepackage{sbc-template}

* Introdução

  CLEFIA é um algoritmo de cifragem de blocos, desenvolvido pela SONY,
  apresentado em 2007. O tamanho do  bloco é de 128 bits, enquanto que
  o tamanho da chave pode ser de 128, 192 ou 256 bits, fazendo com que
  ele seja compatível com a interface do cifrador AES.

  CLEFIA  foi criado  devido ao  aumento da  demanda  por /lightweight
  cryptography/.  /Lightweight  cryptography/  consiste de  mecanismos
  criptográficos   que  fornecem   segurança  para   dispositivos  com
  capacidades     limitadas,     como     por    exemplo,     sensores
  wireless.  Portanto, CLEFIA  fornece um  alto level  de  segurança e
  ainda  tem  uma elevada  perfomance  tanto  em  software, quanto  em
  hardware.

  Nosso  trabalho consiste  de implementar  o CLEFIA  em  software, na
  linguagem C. Foi  implementado todas as versões de  tamanho de chave
  (128, 192 e  256 bits) e ainda o modo  de operação CBC (Cipher-block
  chaining). Também foram realizados testes de cifragens e decifragens
  de arquivos grandes,  utilizando o modo CBC. Os  mesmos testes foram
  realizados  com o  cifrador AES  também no  modo CBC,  disponível na
  biblioteca   OpenSSL.  Dessa   forma,  foi   possível   comparar  os
  resultados.

* Algoritmo CLEFIA

  O algoritmo CLEFIA consiste em  duas partes, a de geração de chaves,
  e a  do processamento dos dados,  que são as funções  de encriptar e
  decriptar.

  Essa seção irá  descrever com detalhes todas as  funções usadas pelo
  CLEFIA, tanto para a parte de geração de chaves, quanto para a parte
  de encriptar e desencriptar.

** Generalized Feistel Network
    
    CLEFIA utiliza  um 4-branch e  um 8-branch do  Generalized Feistel
    Network(GFN). O  4-branch é utilizado  nas funções de  encriptar e
    decriptar e  também na geração  de chaves no  modo 128 bits.  Já o
    8-branch é aplicado apenas na geração  de chaves do modo 192 e 256
    bits.

   Chamaremos de $GFN_{d, r}$ um GFN onde $d$ é o tamanho do branch, e
   $r$ é o número de rounds.  Abaixo iremos definir o $GFN_{4, r}$ e o
   $GFN_{8,  r}$. Note  que ambos  utilizam as  funções $F$  que serão
   mostradas na próxima subseção. \\

   *GFN_{4,r}(RK_{0}, ..., RK_{2r-1}, X_0, X_1, X_2, X_3)*

   *Entrada* : 32-bit round keys RK_{0}, ..., RK_{2r-1}, \\
               32-bit data X_0, X_1, X_2, X_3,


   *Saída*: 32-bit data Y_0, Y_1, Y_2, Y_3

   *Passo 1.* T_0 | T_1 | T_2 | T_3 \leftarrow X_0 | X_1 | X_2 | X_3

   *Passo 2.* Para i = 0 até $r-1$ faça:

   *Passo 2.1.* T_1 \leftarrow T_1 \oplus F0(RK_{2i},T_0),
                T_3 \leftarrow T_3 \oplus F1(RK_{2i + 1}, T_2)

   *Passo 2.2.* T_0 | T_1 | T_2 | T_3 \leftarrow T_1 | T_2 | T_3 | T_0

   *Passo 3.* Y_0 | Y_1 | Y_2 | Y_3 \leftarrow T_3 | T_0 | T_1 | T_2 

   *GFN_{8,r}(RK_{0}, ..., RK_{4r-1}, X_0, X_1, ..., X_7)*

   *Entrada* : 32-bit round keys RK_{0}, ..., RK_{4r-1}, \\
               32-bit data X_0, X_1, X_2, X_3, X_4, X_5, X_6, X_7,

   *Saída*: 32-bit data Y_0, Y_1, Y_2, Y_3, Y_4, Y_5, Y_6, Y_7

   *Passo 1.* T_0 | T_1 | ... | T_7 \leftarrow X_0 | X_1 | ... | X_7

   *Passo 2.* Para i = 0 até $r-1$ faça:

   *Passo 2.1.* T_1 \leftarrow T_1 \oplus F0(RK_{4i}, T_0), \\
                T_3 \leftarrow T_3 \oplus F1(RK_{4i + 1}, T_2), \\
                T_5 \leftarrow T_5 \oplus F0(RK_{4i + 2}, T_4), \\
                T_7 \leftarrow T_7 \oplus F1(RK_{4i + 3}, T_6)

   *Passo 2.2.* T_0 | T_1 | ... | T_6 | T_7 \leftarrow T_1 | T_2 | ... | T_7 | T_0

   *Passo 3.* Y_0 | Y_1 | ... | Y_6 | Y_7 \leftarrow T_7 | T_0 | ... |
   T_5 | T_6
   
   Temos também a necessidade de gerar a inversa da GFN_{4, r} para
   que seja usada na função de decriptar. Abaixo, ela é apresentada

   *GFNINV_{4,r}(RK_{0}, ..., RK_{2r-1}, X_0, X_1, X_2, X_3)*

   *Entrada* : 32-bit round keys RK_{0}, ..., RK_{2r-1}, \\
               32-bit data X_0, X_1, X_2, X_3,

   *Saída*: 32-bit data Y_0, Y_1, Y_2, Y_3

   *Passo 1.* T_0 | T_1 | T_2 | T_3 <- X_0 | X_1 | X_2 | X_3

   *Passo 2.* Para i = 0 até $r-1$ faça: 

   *Passo 2.1.* T_1 <- T_1 \oplus F0(RK_{2(r - i) - 2}, T_0),
   T_3 <- T_3 \oplus F1(RK_{2(r - i) - 1}, T_2)

   *Passo 2.2.* T_0 | T_1 | T_2 | T_3 <- T_3 | T_0 | T_1 | T_2

   *Passo 3.* Y_0 | Y_1 | Y_2 | Y_3 <- T_1 | T_2 | T_3 | T_0


   
** Funções F

    Já vimos que tanto o 4-branch GFN quanto o 8-branch GNF, utiliza
    duas funções F, denominadas F0 e F1. Abaixo, iremos descrevê-las.

     
    *F0(RK, x)*

    *Entrada* : 32-bit round key RK, 32-bit data x,

    *Saída*: 32-bit data y

    *Passo 1.* T <- RK XOR x

    *Passo 2.* Let T = T_0 | T_1 | T_2 | T_3, where Ti is 8-bit data, \\
               T_0 <- S0(T_0), \\
               T_1 <- S1(T_1), \\
               T_2 <- S0(T_2), \\
               T_3 <- S1(T_3)

    *Passo 3.* Let y = y0 | y1 | y2 | y3, where yi is 8-bit data,
               y <- M0 trans((T_0, T_1, T_2, T_3))

    *F1(RK, x)*

    *Entrada* : 32-bit round key RK, 32-bit data x,

    *Saída*: 32-bit data y

    *Passo 1.* T <- RK XOR x

    *Passo 2.* Let T = T_0 | T_1 | T_2 | T_3, where Ti is 8-bit data,
               T_0 <- S1(T_0),
               T_1 <- S0(T_1),
               T_2 <- S1(T_2),
               T_3 <- S0(T_3)

    *Passo 3.* Let y = y0 | y1 | y2 | y3, where yi is 8-bit data,
               y <- M1 trans((T_0, T_1, T_2, T_3))

    Ambas as funções utilizam as S-boxes que serão mostradas abaixo.

** S-boxes

   CLEFIA utiliza dois tipos diferentes de S-box, S0 e S1. As tabelas
   abaixo mostram-nas. Temos que todos os valores estão em
   hexadecimais, e para uma entrada de 8-bit temos que a saída é
   gerada a partir da posição (i, j), onde i é formada pelos 4
   primeiros bits e j pelos 4 últimos.

       Tabela 1: S-Box S0

   \begin{verbatim}
      .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .a .b .c .d .e .f
   0. 57 49 d1 c6 2f 33 74 fb 95 6d 82 ea 0e b0 a8 1c
   1. 28 d0 4b 92 5c ee 85 b1 c4 0a 76 3d 63 f9 17 af
   2. bf a1 19 65 f7 7a 32 20 06 ce e4 83 9d 5b 4c d8
   3. 42 5d 2e e8 d4 9b 0f 13 3c 89 67 c0 71 aa b6 f5
   4. a4 be fd 8c 12 00 97 da 78 e1 cf 6b 39 43 55 26
   5. 30 98 cc dd eb 54 b3 8f 4e 16 fa 22 a5 77 09 61
   6. d6 2a 53 37 45 c1 6c ae ef 70 08 99 8b 1d f2 b4
   7. e9 c7 9f 4a 31 25 fe 7c d3 a2 bd 56 14 88 60 0b
   8. cd e2 34 50 9e dc 11 05 2b b7 a9 48 ff 66 8a 73
   9. 03 75 86 f1 6a a7 40 c2 b9 2c db 1f 58 94 3e ed
   a. fc 1b a0 04 b8 8d e6 59 62 93 35 7e ca 21 df 47
   b. 15 f3 ba 7f a6 69 c8 4d 87 3b 9c 01 e0 de 24 52
   c. 7b 0c 68 1e 80 b2 5a e7 ad d5 23 f4 46 3f 91 c9
   d. 6e 84 72 bb 0d 18 d9 96 f0 5f 41 ac 27 c5 e3 3a
   e. 81 6f 07 a3 79 f6 2d 38 1a 44 5e b5 d2 ec cb 90
   f. 9a 36 e5 29 c3 4f ab 64 51 f8 10 d7 bc 02 7d 8e
   \end{verbatim}
   Tabela 2: S-Box S1

   \begin{verbatim}
      .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .a .b .c .d .e .f
   0. 6c da c3 e9 4e 9d 0a 3d b8 36 b4 38 13 34 0c d9
   1. bf 74 94 8f b7 9c e5 dc 9e 07 49 4f 98 2c b0 93
   2. 12 eb cd b3 92 e7 41 60 e3 21 27 3b e6 19 d2 0e
   3. 91 11 c7 3f 2a 8e a1 bc 2b c8 c5 0f 5b f3 87 8b
   4. fb f5 de 20 c6 a7 84 ce d8 65 51 c9 a4 ef 43 53
   5. 25 5d 9b 31 e8 3e 0d d7 80 ff 69 8a ba 0b 73 5c
   6. 6e 54 15 62 f6 35 30 52 a3 16 d3 28 32 fa aa 5e
   7. cf ea ed 78 33 58 09 7b 63 c0 c1 46 1e df a9 99
   8. 55 04 c4 86 39 77 82 ec 40 18 90 97 59 dd 83 1f
   9. 9a 37 06 24 64 7c a5 56 48 08 85 d0 61 26 ca 6f
   a. 7e 6a b6 71 a0 70 05 d1 45 8c 23 1c f0 ee 89 ad
   b. 7a 4b c2 2f db 5a 4d 76 67 17 2d f4 cb b1 4a a8
   c. b5 22 47 3a d5 10 4c 72 cc 00 f9 e0 fd e2 fe ae
   d. f8 5f ab f1 1b 42 81 d6 be 44 29 a6 57 b9 af f2
   e. d4 75 66 bb 68 9f 50 02 01 3c 7f 8d 1a 88 bd ac
   f. f7 e4 79 96 a2 fc 6d b2 6b 03 e1 2e 7d 14 95 1d
   \end{verbatim}

** Matrizes de Difusão

    Vimos que é necessário a multiplicação de um vetor T pelas
    matrizes M0 e M1 na função F0 e F1 respectivamente.

    Abaixo é mostrado como é feito essa multiplicação.

   y = M0 trans((T_0, T_1, T_2, T_3)):

     y0 =         T_0  XOR (0x02 * T_1) XOR (0x04 * T_2) XOR (0x06 * T_3),
     y1 = (0x02 * T_0) XOR         T_1  XOR (0x06 * T_2) XOR (0x04 * T_3),
     y2 = (0x04 * T_0) XOR (0x06 * T_1) XOR         T_2  XOR (0x02 * T_3),
     y3 = (0x06 * T_0) XOR (0x04 * T_1) XOR (0x02 * T_2) XOR         T_3

   y = M1 trans((T_0, T_1, T_2, T_3)):

     y0 =         T_0  XOR (0x08 * T_1) XOR (0x02 * T_2) XOR (0x0a * T_3),
     y1 = (0x08 * T_0) XOR         T_1  XOR (0x0a * T_2) XOR (0x02 * T_3),
     y2 = (0x02 * T_0) XOR (0x0a * T_1) XOR         T_2  XOR (0x08 * T_3),
     y3 = (0x0a * T_0) XOR (0x02 * T_1) XOR (0x08 * T_2) XOR         T_3

     Temos que o sinal * indica multiplicação em GF(2^8) onde o
     polinômio primitivo é z^8 + z^4 + z^3 + z^2 + 1. Teremos uma
     seção abaixo explicando como é feito as operações em GF(2^8).

** Algoritmo de encriptação


** Algoritmo de desencriptação

* Resultados experimentais
  Com o  intuito de compararar o  algoritmo Clefia com  o AES, fizemos
  vários testes  de cifragem e decifragem. Os  tempos obtidos aparecem
  nas tabelas abaixo. 
  
  É óbvio  que a  implementação do AES  da biblioteca OpenSSL  é muito
  rápida,  já que o  código aberto  vem sendo  testado e  otimizado há
  bastante tempo. 
  
  Nosso código, por outro lado,  foi escrito por duas pessoas apenas e
  sem  o tempo  necessário para  fazer otimizações  mais  profundas no
  código.  
  
  Apesar disso, a primeira implementação  era $10\%$ mais lenta. O que
  fizemos para acelerar um pouco a execução foram
  pequenas otimizações de código, como /loop unrolling/ de alguns
  laços e trocar funções por  macros, que são substituídas em tempo de
  compilação.  Acreditamos que com mais tempo e mais otimizações
  poderíamos deminuir drasticamente os tempos apresentados.
  
  Nas tabelas a seguir, temos os tempos de execução de cada um dos dez
  testes feitos.  O arquivo cifrado  é uma imagem de  uma distribuição
  Linux, de 200278016 bytes.

|---------------+-------------+----------------|
| Cifrar        | AES-128 (s) | Clefia-128 (s) |
|---------------+-------------+----------------|
| Teste 1       |       1.996 |         31.778 |
| Teste 2       |       1.933 |         31.783 |
| Teste 3       |       2.030 |         31.773 |
| Teste 4       |       1.933 |         31.782 |
| Teste 5       |       2.026 |         31.782 |
| Teste 6       |       2.059 |         31.786 |
| Teste 7       |       2.078 |         31.791 |
| Teste 8       |       2.124 |         31.785 |
| Teste 9       |       1.948 |         31.904 |
| Teste 10      |       1.981 |         31.775 |
|---------------+-------------+----------------|
| Média         |      2.0108 |        31.7939 |
| Desvio Padrão |      0.0644 |         0.0390 |
|---------------+-------------+----------------|

|---------------+-------------+----------------|
| Decifrar      | AES-128 (s) | Clefia-128 (s) |
|---------------+-------------+----------------|
| Teste 1       |       2.081 |         33.233 |
| Teste 2       |       2.025 |         33.256 |
| Teste 3       |       2.059 |         33.261 |
| Teste 4       |       2.065 |         33.236 |
| Teste 5       |       2.051 |         33.268 |
| Teste 6       |       2.021 |         33.499 |
| Teste 7       |       2.044 |          33.13 |
| Teste 8       |       2.029 |         33.034 |
| Teste 9       |       2.034 |         33.335 |
| Teste 10      |       2.049 |         33.243 |
|---------------+-------------+----------------|
| Média         |      2.0458 |        33.2495 |
| Desvio Padrão |      0.0191 |         0.1207 |
|---------------+-------------+----------------|

  
